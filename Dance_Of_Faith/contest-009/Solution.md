# The Solution

题目按CF顺序排序

-------------------------

## #A -Greg and Array

> 时间限制：  1.5s
>
> 空间限制：  256MB
>
> 主要算法：  差分
>
> 时间复杂度：O(N)
>
> 空间复杂度：O(N)

### 题意
给定一个初始序列，给出M个操作，每个操作定义为将区间Li~Ri每个数都加上Xi。给定Q个询问，每个询问都执行的qi~qj个操作。输出最后的数列。
### 题解
差分思想：假设要在区间[l,r]加上x，则用一个空数组d，将d[l]+=x,将d[r+1]-=x，然后对d数组做一遍前缀和得到s，则s数组的[l,r]都是x了。
因为这是离线操作，故用一个数组来记录第i个操作被操作了几次（此处用差分思想实现），最后只要在统计答案时枚举每个操作，在标记时乘上该操作的使用次数即可。

---------------------------

## #B Greg and Graph

> 时间限制：  3s
>
> 空间限制：  256MB
>
> 主要算法：  Floyd
>
> 时间复杂度：O(N^3)
>
> 空间复杂度：O(N^2)

### 题意
有N个点，并且一个完全有向图。将N点依次删除，给并定删点的顺序；求每次删点之后剩余图中每两点之间最短距离和之和。
### 题解
如果每次删点后都跑一次Floyd，那肯定超时。既然删点难处理，就将其倒着做，转化为添点，每一次将点添进来，都作为中转点让其他点更新最短路，这样可以很巧妙地将第一维。

----------------------------

## #C Greg and Friends

> 时间限制：  2s
>
> 空间限制：  256MB
>
> 主要算法：  DP+BFS
>
> 时间复杂度：O(N^4)
>
> 空间复杂度：O(N^2)

### 题意
有N个人要过河，每个人的体重要么为50，要么为100；船的最大载量为k，求在最少步数的情况下的方案数。
### 题解
要最少步数，自然想到BFS，而这道题一看又是DP的类型。用dp[a][b][c]表示在原岸还有a个重50的人，b个重100的人，此时船在c岸（0为原岸，1为对岸）时的方案数，vis[a][b][c]表示到当前状态的最少步数（打不到为0）。转移时枚举过河的50重的人和100重的人的个数，拿此时船在原岸的情况来说：dp[a-i][b-j][!c]+=dp[a][b][c]*C[a][i]*C[b][j]（注：C是组合数）在对岸则相反。

--------------------------------


## #D Greg and Caves

> 时间限制：  2s
>
> 空间限制：  256MB
>
> 主要算法：  递推+前缀和优化
>
> 时间复杂度：O(N^2)
>
> 空间复杂度：O(N^2)

### 题意

![the picture](http://images2015.cnblogs.com/blog/1185618/201706/1185618-20170623082555210-125396151.png)

### 题解
考虑这样的状态f[i][j] 表示前i行第i行长度恰好是j的方案数  g[i][j]表示前i行，第i行的长度小于等于j的方案数。
显然，比如说：

g[i][3]=f[i][1] * 3 + f[i][2] * 2 + f[i][3]

g[i][4]=f[i][1] * 4 + f[i][2] * 3 + f[i][3] * 2 + f[i][4]

到这里就明白了，可以这么递推：

g[i][4]=g[i][3] + f[i][1] + f[i][2] + f[i][3] + f[i][4];

而f数组可以用前缀和来代替，这样转移时就可以是O(1)的了。
然后统计时对于i以下的行同样可以用已有的状态表达，故：

ans += f[i][j]*(g[n-i][j]-f[n-i][j]+1)*(m-j+1)（m-j+1可以理解为每种方案时都能在m个列间滑动） 

---------------------------

## #E Yaroslav and Points

> 时间限制：  5s
>
> 空间限制：  256MB
>
> 主要算法：  线段树
>
> 时间复杂度：O(NlogN)
>
> 空间复杂度：O(NlogN)

### 题意
数轴上初始存在N个点，并和它原有的坐标。现有M个操作：1. 将坐标为x的点右移y个单位； 2. 询问区间整数区间[li,ri]内，所有点每两点之间距离和。
### 题解
暴力线段树。只是要动态开点。
每个节点存放三个属性：ans,sum,cnt，分别表示该点管辖的区间内的每两点距离和，该区间内所有点的坐标之和，该区间内点的个数。
于是节点更新时：

T.cnt=L.cnt+R.cnt;

T.sum=L.sum+R.sum;

T.ans=L.ans+R.ans+L.cnt*R.sum-L.sum*R.cnt;（这个表达式的得出可以轻松证明或手模得出）

（小技巧：坐标表示时可以都加上1e9变为正数）
